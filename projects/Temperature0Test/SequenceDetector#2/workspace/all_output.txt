Core Blocks:
1. SequenceDetector: The main module that implements the sequence detection logic.

Now let's proceed with the file contents.

**sequence_detector.v**

```verilog
module SequenceDetector (
  input wire clk,
  input wire rst_n,
  input wire [2:0] data,
  output reg sequence_found
);

  // State definition
  typedef enum logic [2:0] {
    WAITING,
    DETECTING_1,
    DETECTING_2,
    DETECTING_3,
    DETECTING_4,
    DETECTING_5,
    DETECTING_6,
    DETECTING_7,
    SEQUENCE_FOUND
  } State;

  // Internal signals
  reg [2:0] current_state;
  reg [2:0] next_state;

  // State transition and output logic
  always @(posedge clk or negedge rst_n) begin
    if (~rst_n) begin
      current_state <= WAITING;
      sequence_found <= 0;
    end else begin
      current_state <= next_state;
      sequence_found <= (next_state == SEQUENCE_FOUND);
    end
  end

  // State transition and output logic
  always @(current_state, data) begin
    next_state = current_state;
    case (current_state)
      WAITING:
        if (data == 3'b001)
          next_state = DETECTING_1;
      DETECTING_1:
        if (data == 3'b101)
          next_state = DETECTING_2;
      DETECTING_2:
        if (data == 3'b110)
          next_state = DETECTING_3;
      DETECTING_3:
        if (data == 3'b000)
          next_state = DETECTING_4;
      DETECTING_4:
        if (data == 3'b110)
          next_state = DETECTING_5;
      DETECTING_5:
        if (data == 3'b110)
          next_state = DETECTING_6;
      DETECTING_6:
        if (data == 3'b011)
          next_state = DETECTING_7;
      DETECTING_7:
        if (data == 3'b101)
          next_state = SEQUENCE_FOUND;
      default:
        next_state = WAITING;
    endcase
  end

endmodule
```

This is the main module `SequenceDetector` that implements the sequence detection logic. It has inputs `clk`, `rst_n`, and `data`, and an output `sequence_found`. The module uses a state machine to detect the sequence of binary input values. The state machine transitions based on the current state and the input data. The `sequence_found` output is set to 1 when the sequence is detected.

The module defines an enumerated type `State` to represent the different states of the state machine. It also declares internal signals `current_state` and `next_state` to hold the current and next states of the state machine.

The module has two always blocks. The first always block handles the state transition and output logic. It updates the `current_state` and `sequence_found` registers on the rising edge of the clock or when the reset signal is asserted. The second always block handles the state transition logic based on the current state and input data. It updates the `next_state` signal accordingly.

The module starts in the `WAITING` state and transitions through the states `DETECTING_1` to `DETECTING_7` based on the input data. If the input data matches the final sequence `3'b101` in the `DETECTING_7` state, the module transitions to the `SEQUENCE_FOUND` state and sets `sequence_found` to 1. If the input data does not match any expected sequence, the module transitions back to the `WAITING` state.

This completes the implementation of the Verilog model for the sequence detector.