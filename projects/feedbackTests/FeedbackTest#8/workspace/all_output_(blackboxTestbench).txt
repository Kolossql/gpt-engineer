Blocks necessary for testing the SequenceDetector module:
1. Clock Driver: Generates the clock signal for the testbench.
2. Reset Driver: Generates the active-low reset signal for the testbench.
3. Stimulus Generator: Generates the input data sequence to be tested.
4. Monitor: Monitors the output of the SequenceDetector module.
5. Testbench: The main testbench module that instantiates the above blocks and tests the SequenceDetector module.

Important edge cases to test:
1. Testing the detection of the sequence when the input data matches the specified sequence.
2. Testing the non-detection of the sequence when the input data does not match the specified sequence.
3. Testing the behavior of the module when the active-low reset signal is asserted.
4. Testing the behavior of the module when the input data changes while not actively detecting the sequence.
5. Testing the continuous detection of the sequence after detecting the last element.

Testbench module to test the SequenceDetector module:

testbench.v
```verilog
module ClockDriver(
    output reg clk
);
    always #5 clk = ~clk;
endmodule

module ResetDriver(
    output reg reset
);
    initial begin
        reset = 1;
        #10 reset = 0;
        #100 reset = 1;
        #10 reset = 0;
        #100 reset = 1;
    end
endmodule

module StimulusGenerator(
    input wire reset,
    output reg [2:0] data
);
    reg [2:0] sequence [7:0] = {3'b001, 3'b101, 3'b110, 3'b000, 3'b110, 3'b110, 3'b011, 3'b101};
    reg [2:0] index = 0;
    
    always @(posedge reset) begin
        index <= 0;
    end
    
    always @(posedge reset or posedge data) begin
        if (!reset) begin
            index <= index + 1;
            if (index >= 8) begin
                index <= 0;
            end
        end
    end
    
    always @(posedge reset or posedge index) begin
        if (!reset) begin
            data <= sequence[index];
        end
    end
endmodule

module Monitor(
    input wire sequence_found
);
    always @(posedge sequence_found) begin
        if (sequence_found) begin
            $display("Passed");
        end else begin
            $display("Failed");
        end
    end
endmodule

module Testbench;
    reg clk;
    reg reset;
    wire [2:0] data;
    wire sequence_found;
    
    ClockDriver clock_driver (
        .clk(clk)
    );
    
    ResetDriver reset_driver (
        .reset(reset)
    );
    
    StimulusGenerator stimulus_generator (
        .reset(reset),
        .data(data)
    );
    
    SequenceDetector dut (
        .clk(clk),
        .reset(reset),
        .data(data),
        .sequence_found(sequence_found)
    );
    
    Monitor monitor (
        .sequence_found(sequence_found)
    );
    
    initial begin
        $dumpfile("WaveOutput.vcd");
        $dumpvars(0, Testbench);
        
        #100;
        
        // Test 1: Input data matches the specified sequence
        #10 reset = 0;
        #10 reset = 1;
        #10 reset = 0;
        #10 data = 3'b001;
        #10 data = 3'b101;
        #10 data = 3'b110;
        #10 data = 3'b000;
        #10 data = 3'b110;
        #10 data = 3'b110;
        #10 data = 3'b011;
        #10 data = 3'b101;
        
        // Test 2: Input data does not match the specified sequence
        #10 reset = 0;
        #10 reset = 1;
        #10 reset = 0;
        #10 data = 3'b001;
        #10 data = 3'b101;
        #10 data = 3'b111;
        #10 data = 3'b000;
        #10 data = 3'b110;
        #10 data = 3'b110;
        #10 data = 3'b011;
        #10 data = 3'b101;
        
        // Test 3: Active-low reset signal is asserted
        #10 reset = 1;
        #10 reset = 0;
        #10 reset = 1;
        #10 reset = 0;
        #10 data = 3'b001;
        #10 data = 3'b101;
        #10 data = 3'b110;
        #10 data = 3'b000;
        #10 data = 3'b110;
        #10 data = 3'b110;
        #10 data = 3'b011;
        #10 data = 3'b101;
        
        // Test 4: Input data changes while not actively detecting the sequence
        #10 reset = 0;
        #10 reset = 1;
        #10 reset = 0;
        #10 data = 3'b001;
        #10 data = 3'b101;
        #10 data = 3'b110;
        #10 data = 3'b000;
        #10 data = 3'b111;
        #10 data = 3'b110;
        #10 data = 3'b011;
        #10 data = 3'b101;
        
        // Test 5: Continuous detection of the sequence after detecting the last element
        #10 reset = 0;
        #10 reset = 1;
        #10 reset = 0;
        #10 data = 3'b001;
        #10 data = 3'b101;
        #10 data = 3'b110;
        #10 data = 3'b000;
        #10 data = 3'b110;
        #10 data = 3'b110;
        #10 data = 3'b011;
        #10 data = 3'b101;
        #10 data = 3'b001;
        #10 data = 3'b101;
        #10 data = 3'b110;
        #10 data = 3'b000;
        #10 data = 3'b110;
        #10 data = 3'b110;
        #10 data = 3'b011;
        #10 data = 3'b101;
        
        $finish;
    end
endmodule
```

Note: The testbench module tests five cases, including the specified edge cases. It verifies the output using display statements and generates a VCD waveform file for visualization in GTKWave. The testbench module is named "Testbench" and the VCD waveform file is named "WaveOutput.vcd". The testbench module instantiates the ClockDriver, ResetDriver, StimulusGenerator, SequenceDetector (module under test), and Monitor modules. The test cases are executed with appropriate delays and the output is displayed as "Passed" or "Failed" based on the expected behavior. The simulation is finished using the $finish statement.