[{"type": "system", "data": {"content": "You will get instructions for code to write.\nYou will write a very long answer. Make sure that every detail of the architecture is, in the end, implemented as code.\n\nThink step by step and reason yourself to the right decisions to make sure we get it right.\nYou will first lay out the names of the core modules, blocks that will be necessary, as well as a quick comment on their purpose.\n\nThen you will output the content of each file including ALL code.\nEach file must strictly follow a markdown code block format, where the following tokens must be replaced such that\nFILENAME is the lowercase file name including the file extension,\nLANG is the markup code block language for the code's language, and CODE is the code:\n\nFILENAME\n```LANG\nCODE\n```\n\nDo not comment on what every file does\n\nYou will start with the \"entrypoint\" file, then go to the ones that are imported by that file, and so on.\nPlease note that the code should be fully functional. No placeholders.\n\nFollow a language and framework appropriate best practice file naming convention.\nMake sure that code in different files are compatible with each other.\nEnsure to implement all code, if you are unsure, write a plausible implementation.\nBefore you finish, double check that all parts of the architecture is present in the files.\n\nUseful to know:\nYou almost always put different classes in different files.\nFor Verilog, you always create a complete testbench for each modules. \nYou try to add comments explaining very complex bits of logic.\nYou always follow the best practices for the requested languages in terms of describing the code written as a defined\npackage/project.", "additional_kwargs": {}}}, {"type": "human", "data": {"content": "Buffered UART:\n        Implement a system in a caravel user project that implements  a buffered UART for data acquisition that works in the following manner:\n        (1) A UART with selectable baud rate determined by the core clock\n            rate divided by a 16-bit number held in a register.  The fastest\n            rate is the core clock frequency divided by 8.  All register\n            values less than 8 can be treated as the same as divide-by-8.\n            Only the receive function of the UART needs to be implemented.\n        (2) The UART is connected to one input GPIO.  Use caravel GPIO[5]\n            for Rx (receive), which matches the function of that pin for the\n            management SoC.\n        (3) There is a dual-port memory of 1kB that holds (buffers) any\n            input data until they are read by the SoC.  The memory will be\n            one of the SRAM macros, so there is a defined module function\n            and pinout for it.\n        (4) There is a small memory controller that maintains two pointers\n            (addresses) to the SRAM, one for the bottom of the buffer\n            (oldest data) and one for the top of the buffer (newest data).\n            The initial pointer values (addresses) for the buffer top and\n            bottom are both zero.\n        (5) There is a wishbone interface to the caravel SoC.  It decodes\n            five different addresses for these registered values:\n                (1) Input data word (read only) (from SRAM read-only port,\n                    the buffer bottom)\n                (2) A configuration word for controlling the UART (enable\n                    and baud rate) (read/write)\n                (3) Buffer status (empty, full, near empty, near full,\n                    overflow, underflow)\n                (4) Buffer address top (read only) (diagnostic)\n                (5) Buffer address bottom (read only) (diagnostic)\n            The wishbone address for the user project space is 0x30000000.\n            The interface implementation needs only to look at the low byte\n            to decode the five registers above.\n        (5) When the UART receives a byte, it signals to the controller that\n            a byte has been received.  The controller writes the byte to\n            SRAM and increments the address of the top of the buffer.  If the\n            address reaches the end of memory, it loops back to the beginning.\n            If the buffer top equals the buffer bottom, then the \"full\" status\n            is set.  If the buffer top is 10 bytes or less below the buffer\n            bottom, the \"almost full\" status is set.  If the buffer is full\n            when a new UART byte arrives, then it is discarded and the memory\n            pointer is not incremented, and the \"overflow\" status is set.\n        (7) The controller always outputs the SRAM value at the bottom of the\n            buffer which can be read on wishbone address 0.  When a read is\n            requested on the wishbone bus at address 0, the controller\n            acknowledges the read and then increments the pointer to the\n            bottom of the buffer.  If the address reaches the end of memory,\n            it loops back to the beginning.  If the buffer top equals the\n            buffer bottom, then the \"empty\" status is set.  If the buffer\n            top is 10 bytes or less above the buffer bottom, the \"almost\n            empty\" status is set.  If the buffer is empty when a new read\n            is requested, then the memory pointer is not decremented, and\n            the \"underflow\" status is set.\n        The SRAM is module sky130_sram_1kbyte_1rw1r_8x1024_8.v from the\n        sky130_sram_macros library.  Its black-box definition is:\n                module sky130_sram_1kbyte_1rw1r_8x1024_8 (\n                        input  clk0,            // core clock\n                        input  csb0,            // disable\n                        input  web0,            // active low write control\n                        input  [0:0]  wmask0,   // write mask\n                        input  [9:0]  addr0,    // buffer top address\n                        input  [7:0]  din0,     // UART data in\n                        output [7:0]  dout0,    // unused\n                        input  clk1,            // core clock\n                        input  csb1,            // disable\n                        input  [9:0]  addr1,    // buffer bottom address\n                        output [7:0]  dout1     // data out to wishbone\n                );\n        The UART black-box module can be defined as:\n                module uart (\n                        input clk,              // core clock\n                        input resetn,           // active-low reset\n                        input enable,           // enable signal\n                        input rx,               // input (receive) value\n                        input [15:0] divider,   // baud rate clock divider\n                        output [7:0] data_out,  // data byte out\n                        output data_ready       // data ready signal\n                );\n        The wishbone controller can include the memory controller and its\n        black-box module can be defined as:\n                module buffered_uart_wb (\n                        // SoC-wishbone bus facing signals\n                        input wb_clk_i,\n                        input wb_rst_i,\n                        input [31:0] wb_adr_i,\n                        input [31:0] wb_dat_i,\n                        input [3:0]  wb_sel_i,\n                        input wb_we_i,\n                        input wb_cyc_i,\n                        input wb_stb_i,\n                        output wb_ack_o,\n                        output [31:0] wb_dat_o,\n\n                        // Memory (SRAM) connections\n                        output [9:0] buffer_top,\n                        output [9:0] buffer_bottom,\n                        input [7:0]  buffer_output,\n\n                        // UART connections (from internal registers)\n                        input  uart_ready,\n                        output [7:0] uart_value,\n                        output uart_enable,\n                        output uart_divider\n                );", "additional_kwargs": {}, "example": false}}, {"type": "ai", "data": {"content": "Areas that need clarification:\n\n1. The specific method for selecting the baud rate for the UART.\n2. The exact functionality of the configuration word for controlling the UART.\n3. The definition of \"near empty\" and \"near full\" buffer status.\n4. The process for handling \"overflow\" and \"underflow\" status.\n5. The exact functionality of the wishbone interface and its interaction with the SRAM and UART.\n6. The functionality of the memory controller in relation to the SRAM and UART.\n7. The specific roles of the inputs and outputs in the SRAM and UART modules.\n8. The functionality of the wishbone controller and its interaction with the memory controller, SRAM, and UART.", "additional_kwargs": {}, "example": false}}, {"type": "human", "data": {"content": "Make your own assumptions and state them explicitly before starting", "additional_kwargs": {}, "example": false}}, {"type": "ai", "data": {"content": "Assumptions:\n\n1. The baud rate for the UART is selected by writing the desired value to the configuration word register.\n2. The configuration word for controlling the UART includes bits for enabling/disabling the UART and setting the baud rate.\n3. \"Near empty\" and \"near full\" buffer status refer to the buffer being within 10 bytes of being empty or full, respectively.\n4. \"Overflow\" status means that the buffer is full and cannot accept any more data, while \"underflow\" status means that the buffer is empty and cannot provide any more data.\n5. The wishbone interface is used to communicate between the SoC and the user project, including reading and writing data to the SRAM and controlling the UART.\n6. The memory controller manages the read and write operations to the SRAM, including maintaining the buffer top and bottom pointers.\n7. In the SRAM and UART modules, inputs are signals or data coming into the module, while outputs are signals or data going out of the module.\n8. The wishbone controller manages the communication between the SoC and the user project, including controlling the memory controller, SRAM, and UART.", "additional_kwargs": {}, "example": false}}, {"type": "human", "data": {"content": "You will read specifications but not carry them out instead generate a blackbox reference with the following details of the module. Do not write any other description besides what is included in the following format. Do not write any code.\nIn this format ModuleName is the exact name of the module. type is the type of the input or output on the same line. size is the size of the input or output on the same line. Size should be in the format [(bits-1):0]. Size should not be included if the size is 1 bit. name is the exact name of the input or output on the same line.\nFollow the format of the following:\n\nModuleName\n{ \n    //comment on the following input\n    input type size name\n}\n{\n    output type size name\n}", "additional_kwargs": {}, "example": false}}, {"type": "ai", "data": {"content": "uart\n{ \n    //core clock\n    input wire clk\n    //active-low reset\n    input wire resetn\n    //enable signal\n    input wire enable\n    //input (receive) value\n    input wire rx\n    //baud rate clock divider\n    input wire [15:0] divider\n}\n{\n    //data byte out\n    output reg [7:0] data_out\n    //data ready signal\n    output wire data_ready\n}\n\nsky130_sram_1kbyte_1rw1r_8x1024_8\n{ \n    //core clock\n    input wire clk0\n    //disable\n    input wire csb0\n    //active low write control\n    input wire web0\n    //write mask\n    input wire [0:0] wmask0\n    //buffer top address\n    input wire [9:0] addr0\n    //UART data in\n    input wire [7:0] din0\n    //core clock\n    input wire clk1\n    //disable\n    input wire csb1\n    //buffer bottom address\n    input wire [9:0] addr1\n}\n{\n    //unused\n    output wire [7:0] dout0\n    //data out to wishbone\n    output wire [7:0] dout1\n}\n\nbuffered_uart_wb\n{ \n    //SoC-wishbone bus facing signals\n    input wire wb_clk_i\n    input wire wb_rst_i\n    input wire [31:0] wb_adr_i\n    input wire [31:0] wb_dat_i\n    input wire [3:0] wb_sel_i\n    input wire wb_we_i\n    input wire wb_cyc_i\n    input wire wb_stb_i\n    //Memory (SRAM) connections\n    input wire [7:0] buffer_output\n    //UART connections (from internal registers)\n    input wire uart_ready\n}\n{\n    //SoC-wishbone bus facing signals\n    output wire wb_ack_o\n    output wire [31:0] wb_dat_o\n    //Memory (SRAM) connections\n    output wire [9:0] buffer_top\n    output wire [9:0] buffer_bottom\n    //UART connections (from internal registers)\n    output wire [7:0] uart_value\n    output wire uart_enable\n    output wire uart_divider\n}", "additional_kwargs": {}, "example": false}}]